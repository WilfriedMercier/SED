
<!DOCTYPE html>

<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>functools — Resolved SED-fitting wrapper 0.5 documentation</title>
<link href="../_static/css/theme.min.css" rel="stylesheet" type="text/css"/>
<link href="../_static/css/custom.css" rel="stylesheet" type="text/css"/>
<link href="../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../_static/css/theme.min.css" rel="stylesheet" type="text/css"/>
<link href="../_static/plot_directive.css" rel="stylesheet" type="text/css"/>
<link href="../genindex.html" rel="index" title="Index"/>
<link href="../search.html" rel="search" title="Search"/>
</head>
<body>
<header>
<div class="container">
<a class="site-nav-toggle hidden-lg-up"><i class="icon-menu"></i></a>
<a class="site-title" href="../index.html">
                Resolved SED-fitting wrapper
            </a>
</div>
</header>
<div class="breadcrumbs-outer hidden-xs-down">
<div class="container">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="breadcrumbs">
<li><a href="../index.html">Docs</a></li>
<li><a href="index.html">Module code</a></li>
<li>functools</li>
<li class="breadcrumbs-aside">
</li>
</ul>
</div>
</div>
</div>
<div class="main-outer">
<div class="container">
<div class="row">
<div class="col-12 col-lg-3 site-nav">
<div role="search">
<form action="../search.html" class="search" method="get">
<div class="icon-input">
<input name="q" placeholder="Search" type="text"/>
<span class="icon-search"></span>
</div>
<input class="d-hidden" type="submit" value="Go"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
<div class="site-nav-tree">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../setup.html">Installation and setup</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../setup.html#required-dependencies">Required dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../setup.html#sed-fitting-codes-installation">SED fitting codes installation</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorial introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/lephare.html">LePhare</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/cigale.html">Cigale</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#nomenclature">Nomenclature</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#pre-processing-step">Pre-processing step</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#step-1-building-filter-and-filterlist-objects">Step 1: Building <code class="xref py py-class docutils literal notranslate">Filter</code> and <code class="xref py py-class docutils literal notranslate">FilterList</code> objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#step-2-generate-a-catalogue-object">Step 2: Generate a <code class="xref py py-class docutils literal notranslate">Catalogue</code> object</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#step-3-create-a-sed-object">Step 3: Create a <code class="xref py py-class docutils literal notranslate">SED</code> object</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#step-4-run-the-sed-fitting">Step 4: Run the SED fitting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#step-5-produce-a-resolved-map">Step 5: Produce a resolved map</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../examples/example1.html">1. Resolved stellar mass map with LePhare</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/example2.html">2. Resolved SFR map from an already existing LePhare output file</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">―――――――――――――――</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../API/index.html">API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../API/catalogues.html">Catalogue classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API/filters.html">Filter classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API/misc/index.html">Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API/outputs.html">SED fitting code output classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API/sed.html">SED classes</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="col-12 col-lg-9">
<div class="document">
<h1>Source code for functools</h1><div class="highlight"><pre>
<span></span><span class="sd">"""functools.py - Tools for working with functions and callable objects</span>
<span class="sd">"""</span>
<span class="c1"># Python module wrapper for _functools C module</span>
<span class="c1"># to allow utilities written in Python to be added</span>
<span class="c1"># to the functools module.</span>
<span class="c1"># Written by Nick Coghlan &lt;ncoghlan at gmail.com&gt;,</span>
<span class="c1"># Raymond Hettinger &lt;python at rcn.com&gt;,</span>
<span class="c1"># and Łukasz Langa &lt;lukasz at langa.pl&gt;.</span>
<span class="c1">#   Copyright (C) 2006-2013 Python Software Foundation.</span>
<span class="c1"># See C source code for _functools credits/copyright</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'update_wrapper'</span><span class="p">,</span> <span class="s1">'wraps'</span><span class="p">,</span> <span class="s1">'WRAPPER_ASSIGNMENTS'</span><span class="p">,</span> <span class="s1">'WRAPPER_UPDATES'</span><span class="p">,</span>
           <span class="s1">'total_ordering'</span><span class="p">,</span> <span class="s1">'cmp_to_key'</span><span class="p">,</span> <span class="s1">'lru_cache'</span><span class="p">,</span> <span class="s1">'reduce'</span><span class="p">,</span> <span class="s1">'partial'</span><span class="p">,</span>
           <span class="s1">'partialmethod'</span><span class="p">,</span> <span class="s1">'singledispatch'</span><span class="p">]</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">_functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">get_cache_token</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="c1"># import types, weakref  # Deferred to single_dispatch()</span>
<span class="kn">from</span> <span class="nn">reprlib</span> <span class="kn">import</span> <span class="n">recursive_repr</span>
<span class="kn">from</span> <span class="nn">_thread</span> <span class="kn">import</span> <span class="n">RLock</span>


<span class="c1">################################################################################</span>
<span class="c1">### update_wrapper() and wraps() decorator</span>
<span class="c1">################################################################################</span>

<span class="c1"># update_wrapper() and wraps() are tools to help write</span>
<span class="c1"># wrapper functions that can handle naive introspection</span>

<span class="n">WRAPPER_ASSIGNMENTS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'__module__'</span><span class="p">,</span> <span class="s1">'__name__'</span><span class="p">,</span> <span class="s1">'__qualname__'</span><span class="p">,</span> <span class="s1">'__doc__'</span><span class="p">,</span>
                       <span class="s1">'__annotations__'</span><span class="p">)</span>
<span class="n">WRAPPER_UPDATES</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'__dict__'</span><span class="p">,)</span>
<span class="k">def</span> <span class="nf">update_wrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span>
                   <span class="n">wrapped</span><span class="p">,</span>
                   <span class="n">assigned</span> <span class="o">=</span> <span class="n">WRAPPER_ASSIGNMENTS</span><span class="p">,</span>
                   <span class="n">updated</span> <span class="o">=</span> <span class="n">WRAPPER_UPDATES</span><span class="p">):</span>
    <span class="sd">"""Update a wrapper function to look like the wrapped function</span>

<span class="sd">       wrapper is the function to be updated</span>
<span class="sd">       wrapped is the original function</span>
<span class="sd">       assigned is a tuple naming the attributes assigned directly</span>
<span class="sd">       from the wrapped function to the wrapper function (defaults to</span>
<span class="sd">       functools.WRAPPER_ASSIGNMENTS)</span>
<span class="sd">       updated is a tuple naming the attributes of the wrapper that</span>
<span class="sd">       are updated with the corresponding attribute from the wrapped</span>
<span class="sd">       function (defaults to functools.WRAPPER_UPDATES)</span>
<span class="sd">    """</span>
    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">assigned</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">updated</span><span class="p">:</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="c1"># Issue #17482: set __wrapped__ last so we don't inadvertently copy it</span>
    <span class="c1"># from the wrapped function when updating __dict__</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="n">__wrapped__</span> <span class="o">=</span> <span class="n">wrapped</span>
    <span class="c1"># Return the wrapper so this can be used as a decorator via partial()</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="k">def</span> <span class="nf">wraps</span><span class="p">(</span><span class="n">wrapped</span><span class="p">,</span>
          <span class="n">assigned</span> <span class="o">=</span> <span class="n">WRAPPER_ASSIGNMENTS</span><span class="p">,</span>
          <span class="n">updated</span> <span class="o">=</span> <span class="n">WRAPPER_UPDATES</span><span class="p">):</span>
    <span class="sd">"""Decorator factory to apply update_wrapper() to a wrapper function</span>

<span class="sd">       Returns a decorator that invokes update_wrapper() with the decorated</span>
<span class="sd">       function as the wrapper argument and the arguments to wraps() as the</span>
<span class="sd">       remaining arguments. Default arguments are as for update_wrapper().</span>
<span class="sd">       This is a convenience function to simplify applying partial() to</span>
<span class="sd">       update_wrapper().</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">update_wrapper</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">wrapped</span><span class="p">,</span>
                   <span class="n">assigned</span><span class="o">=</span><span class="n">assigned</span><span class="p">,</span> <span class="n">updated</span><span class="o">=</span><span class="n">updated</span><span class="p">)</span>


<span class="c1">################################################################################</span>
<span class="c1">### total_ordering class decorator</span>
<span class="c1">################################################################################</span>

<span class="c1"># The total ordering functions all invoke the root magic method directly</span>
<span class="c1"># rather than using the corresponding operator.  This avoids possible</span>
<span class="c1"># infinite recursion that could occur when the operator dispatch logic</span>
<span class="c1"># detects a NotImplemented result and then calls a reflected method.</span>

<span class="k">def</span> <span class="nf">_gt_from_lt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="o">=</span><span class="bp">NotImplemented</span><span class="p">):</span>
    <span class="s1">'Return a &gt; b.  Computed by @total_ordering from (not a &lt; b) and (a != b).'</span>
    <span class="n">op_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__lt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">op_result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op_result</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">op_result</span> <span class="ow">and</span> <span class="bp">self</span> <span class="o">!=</span> <span class="n">other</span>

<span class="k">def</span> <span class="nf">_le_from_lt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="o">=</span><span class="bp">NotImplemented</span><span class="p">):</span>
    <span class="s1">'Return a &lt;= b.  Computed by @total_ordering from (a &lt; b) or (a == b).'</span>
    <span class="n">op_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__lt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">op_result</span> <span class="ow">or</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

<span class="k">def</span> <span class="nf">_ge_from_lt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="o">=</span><span class="bp">NotImplemented</span><span class="p">):</span>
    <span class="s1">'Return a &gt;= b.  Computed by @total_ordering from (not a &lt; b).'</span>
    <span class="n">op_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__lt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">op_result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op_result</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">op_result</span>

<span class="k">def</span> <span class="nf">_ge_from_le</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="o">=</span><span class="bp">NotImplemented</span><span class="p">):</span>
    <span class="s1">'Return a &gt;= b.  Computed by @total_ordering from (not a &lt;= b) or (a == b).'</span>
    <span class="n">op_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__le__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">op_result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op_result</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">op_result</span> <span class="ow">or</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

<span class="k">def</span> <span class="nf">_lt_from_le</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="o">=</span><span class="bp">NotImplemented</span><span class="p">):</span>
    <span class="s1">'Return a &lt; b.  Computed by @total_ordering from (a &lt;= b) and (a != b).'</span>
    <span class="n">op_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__le__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">op_result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op_result</span>
    <span class="k">return</span> <span class="n">op_result</span> <span class="ow">and</span> <span class="bp">self</span> <span class="o">!=</span> <span class="n">other</span>

<span class="k">def</span> <span class="nf">_gt_from_le</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="o">=</span><span class="bp">NotImplemented</span><span class="p">):</span>
    <span class="s1">'Return a &gt; b.  Computed by @total_ordering from (not a &lt;= b).'</span>
    <span class="n">op_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__le__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">op_result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op_result</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">op_result</span>

<span class="k">def</span> <span class="nf">_lt_from_gt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="o">=</span><span class="bp">NotImplemented</span><span class="p">):</span>
    <span class="s1">'Return a &lt; b.  Computed by @total_ordering from (not a &gt; b) and (a != b).'</span>
    <span class="n">op_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__gt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">op_result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op_result</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">op_result</span> <span class="ow">and</span> <span class="bp">self</span> <span class="o">!=</span> <span class="n">other</span>

<span class="k">def</span> <span class="nf">_ge_from_gt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="o">=</span><span class="bp">NotImplemented</span><span class="p">):</span>
    <span class="s1">'Return a &gt;= b.  Computed by @total_ordering from (a &gt; b) or (a == b).'</span>
    <span class="n">op_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__gt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">op_result</span> <span class="ow">or</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

<span class="k">def</span> <span class="nf">_le_from_gt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="o">=</span><span class="bp">NotImplemented</span><span class="p">):</span>
    <span class="s1">'Return a &lt;= b.  Computed by @total_ordering from (not a &gt; b).'</span>
    <span class="n">op_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__gt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">op_result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op_result</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">op_result</span>

<span class="k">def</span> <span class="nf">_le_from_ge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="o">=</span><span class="bp">NotImplemented</span><span class="p">):</span>
    <span class="s1">'Return a &lt;= b.  Computed by @total_ordering from (not a &gt;= b) or (a == b).'</span>
    <span class="n">op_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__ge__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">op_result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op_result</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">op_result</span> <span class="ow">or</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

<span class="k">def</span> <span class="nf">_gt_from_ge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="o">=</span><span class="bp">NotImplemented</span><span class="p">):</span>
    <span class="s1">'Return a &gt; b.  Computed by @total_ordering from (a &gt;= b) and (a != b).'</span>
    <span class="n">op_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__ge__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">op_result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op_result</span>
    <span class="k">return</span> <span class="n">op_result</span> <span class="ow">and</span> <span class="bp">self</span> <span class="o">!=</span> <span class="n">other</span>

<span class="k">def</span> <span class="nf">_lt_from_ge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="o">=</span><span class="bp">NotImplemented</span><span class="p">):</span>
    <span class="s1">'Return a &lt; b.  Computed by @total_ordering from (not a &gt;= b).'</span>
    <span class="n">op_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__ge__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">op_result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op_result</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">op_result</span>

<span class="n">_convert</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">'__lt__'</span><span class="p">:</span> <span class="p">[(</span><span class="s1">'__gt__'</span><span class="p">,</span> <span class="n">_gt_from_lt</span><span class="p">),</span>
               <span class="p">(</span><span class="s1">'__le__'</span><span class="p">,</span> <span class="n">_le_from_lt</span><span class="p">),</span>
               <span class="p">(</span><span class="s1">'__ge__'</span><span class="p">,</span> <span class="n">_ge_from_lt</span><span class="p">)],</span>
    <span class="s1">'__le__'</span><span class="p">:</span> <span class="p">[(</span><span class="s1">'__ge__'</span><span class="p">,</span> <span class="n">_ge_from_le</span><span class="p">),</span>
               <span class="p">(</span><span class="s1">'__lt__'</span><span class="p">,</span> <span class="n">_lt_from_le</span><span class="p">),</span>
               <span class="p">(</span><span class="s1">'__gt__'</span><span class="p">,</span> <span class="n">_gt_from_le</span><span class="p">)],</span>
    <span class="s1">'__gt__'</span><span class="p">:</span> <span class="p">[(</span><span class="s1">'__lt__'</span><span class="p">,</span> <span class="n">_lt_from_gt</span><span class="p">),</span>
               <span class="p">(</span><span class="s1">'__ge__'</span><span class="p">,</span> <span class="n">_ge_from_gt</span><span class="p">),</span>
               <span class="p">(</span><span class="s1">'__le__'</span><span class="p">,</span> <span class="n">_le_from_gt</span><span class="p">)],</span>
    <span class="s1">'__ge__'</span><span class="p">:</span> <span class="p">[(</span><span class="s1">'__le__'</span><span class="p">,</span> <span class="n">_le_from_ge</span><span class="p">),</span>
               <span class="p">(</span><span class="s1">'__gt__'</span><span class="p">,</span> <span class="n">_gt_from_ge</span><span class="p">),</span>
               <span class="p">(</span><span class="s1">'__lt__'</span><span class="p">,</span> <span class="n">_lt_from_ge</span><span class="p">)]</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">total_ordering</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="sd">"""Class decorator that fills in missing ordering methods"""</span>
    <span class="c1"># Find user-defined comparisons (not those inherited from object).</span>
    <span class="n">roots</span> <span class="o">=</span> <span class="p">{</span><span class="n">op</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">_convert</span> <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="kc">None</span><span class="p">)}</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">roots</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'must define at least one ordering operation: &lt; &gt; &lt;= &gt;='</span><span class="p">)</span>
    <span class="n">root</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>       <span class="c1"># prefer __lt__ to __le__ to __gt__ to __ge__</span>
    <span class="k">for</span> <span class="n">opname</span><span class="p">,</span> <span class="n">opfunc</span> <span class="ow">in</span> <span class="n">_convert</span><span class="p">[</span><span class="n">root</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">opname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
            <span class="n">opfunc</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">opname</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">opname</span><span class="p">,</span> <span class="n">opfunc</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">cls</span>


<span class="c1">################################################################################</span>
<span class="c1">### cmp_to_key() function converter</span>
<span class="c1">################################################################################</span>

<span class="k">def</span> <span class="nf">cmp_to_key</span><span class="p">(</span><span class="n">mycmp</span><span class="p">):</span>
    <span class="sd">"""Convert a cmp= function into a key= function"""</span>
    <span class="k">class</span> <span class="nc">K</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'obj'</span><span class="p">]</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mycmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mycmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mycmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mycmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span>
        <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mycmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="fm">__hash__</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">K</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">_functools</span> <span class="kn">import</span> <span class="n">cmp_to_key</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="c1">################################################################################</span>
<span class="c1">### partial() argument application</span>
<span class="c1">################################################################################</span>

<span class="c1"># Purely functional, no descriptor behaviour</span>
<span class="k">class</span> <span class="nc">partial</span><span class="p">:</span>
    <span class="sd">"""New function with partial application of the given arguments</span>
<span class="sd">    and keywords.</span>
<span class="sd">    """</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="s2">"func"</span><span class="p">,</span> <span class="s2">"args"</span><span class="p">,</span> <span class="s2">"keywords"</span><span class="p">,</span> <span class="s2">"__dict__"</span><span class="p">,</span> <span class="s2">"__weakref__"</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"descriptor '__new__' of partial needs an argument"</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"type 'partial' takes at least one argument"</span><span class="p">)</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"the first argument must be callable"</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">"func"</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span> <span class="o">+</span> <span class="n">args</span>
            <span class="n">tmpkw</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">keywords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">tmpkw</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">keywords</span><span class="p">)</span>
            <span class="n">keywords</span> <span class="o">=</span> <span class="n">tmpkw</span>
            <span class="k">del</span> <span class="n">tmpkw</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">partial</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keywords</span> <span class="o">=</span> <span class="n">keywords</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"descriptor '__call__' of partial needs an argument"</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="n">newkeywords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keywords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">newkeywords</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">keywords</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">newkeywords</span><span class="p">)</span>

    <span class="nd">@recursive_repr</span><span class="p">()</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">qualname</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__qualname__</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)]</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">v</span><span class="si">!r}</span><span class="s2">"</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keywords</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="s2">"functools"</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">"functools.</span><span class="si">{</span><span class="n">qualname</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">', '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="si">}</span><span class="s2">)"</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">qualname</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">', '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="si">}</span><span class="s2">)"</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">keywords</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"argument to __setstate__ must be a tuple"</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"expected 4 items in state, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="n">namespace</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span>
           <span class="p">(</span><span class="n">kwds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwds</span><span class="p">,</span> <span class="nb">dict</span><span class="p">))</span> <span class="ow">or</span>
           <span class="p">(</span><span class="n">namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="nb">dict</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"invalid partial state"</span><span class="p">)</span>

        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="c1"># just in case it's a subclass</span>
        <span class="k">if</span> <span class="n">kwds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">kwds</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span> <span class="c1"># XXX does it need to be *exactly* dict?</span>
            <span class="n">kwds</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">namespace</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">namespace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keywords</span> <span class="o">=</span> <span class="n">kwds</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">_functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="c1"># Descriptor version</span>
<span class="k">class</span> <span class="nc">partialmethod</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">"""Method descriptor with partial application of the given arguments</span>
<span class="sd">    and keywords.</span>

<span class="sd">    Supports wrapping existing descriptors and handles non-descriptor</span>
<span class="sd">    callables as instance methods.</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"descriptor '__init__' of partialmethod "</span>
                            <span class="s2">"needs an argument"</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s1">'func'</span> <span class="ow">in</span> <span class="n">keywords</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">keywords</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'func'</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"type 'partialmethod' takes at least one argument, "</span>
                            <span class="s2">"got </span><span class="si">%d</span><span class="s2">"</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">"__get__"</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"</span><span class="si">{!r}</span><span class="s2"> is not callable or a descriptor"</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>

        <span class="c1"># func could be a descriptor like classmethod which isn't callable,</span>
        <span class="c1"># so we can't inherit from partial (it verifies func is callable)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">partialmethod</span><span class="p">):</span>
            <span class="c1"># flattening is mandatory in order to place cls/self before all</span>
            <span class="c1"># other arguments</span>
            <span class="c1"># it's also more efficient since only one function will be called</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span> <span class="o">+</span> <span class="n">args</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keywords</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">keywords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keywords</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">keywords</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keywords</span> <span class="o">=</span> <span class="n">keywords</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="s2">", "</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">repr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>
        <span class="n">keywords</span> <span class="o">=</span> <span class="s2">", "</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2">=</span><span class="si">{!r}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keywords</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">format_string</span> <span class="o">=</span> <span class="s2">"</span><span class="si">{module}</span><span class="s2">.</span><span class="si">{cls}</span><span class="s2">(</span><span class="si">{func}</span><span class="s2">, </span><span class="si">{args}</span><span class="s2">, </span><span class="si">{keywords}</span><span class="s2">)"</span>
        <span class="k">return</span> <span class="n">format_string</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
                                    <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">,</span>
                                    <span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span>
                                    <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
                                    <span class="n">keywords</span><span class="o">=</span><span class="n">keywords</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_unbound_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
            <span class="n">call_keywords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keywords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">call_keywords</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">keywords</span><span class="p">)</span>
            <span class="n">cls_or_self</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">args</span>
            <span class="n">call_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">cls_or_self</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">call_args</span><span class="p">,</span> <span class="o">**</span><span class="n">call_keywords</span><span class="p">)</span>
        <span class="n">_method</span><span class="o">.</span><span class="n">__isabstractmethod__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__isabstractmethod__</span>
        <span class="n">_method</span><span class="o">.</span><span class="n">_partialmethod</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">_method</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="n">get</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="s2">"__get__"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">get</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_func</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">:</span>
                <span class="c1"># Assume __get__ returning something new indicates the</span>
                <span class="c1"># creation of an appropriate callable</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">new_func</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">keywords</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="vm">__self__</span> <span class="o">=</span> <span class="n">new_func</span><span class="o">.</span><span class="vm">__self__</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If the underlying descriptor didn't do anything, treat this</span>
            <span class="c1"># like an instance method</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_unbound_method</span><span class="p">()</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">__isabstractmethod__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="s2">"__isabstractmethod__"</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>


<span class="c1">################################################################################</span>
<span class="c1">### LRU Cache function decorator</span>
<span class="c1">################################################################################</span>

<span class="n">_CacheInfo</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">"CacheInfo"</span><span class="p">,</span> <span class="p">[</span><span class="s2">"hits"</span><span class="p">,</span> <span class="s2">"misses"</span><span class="p">,</span> <span class="s2">"maxsize"</span><span class="p">,</span> <span class="s2">"currsize"</span><span class="p">])</span>

<span class="k">class</span> <span class="nc">_HashedSeq</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="sd">""" This class guarantees that hash() will be called no more than once</span>
<span class="sd">        per element.  This is important because the lru_cache() will hash</span>
<span class="sd">        the key multiple times on a cache miss.</span>

<span class="sd">    """</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="s1">'hashvalue'</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tup</span><span class="p">,</span> <span class="nb">hash</span><span class="o">=</span><span class="nb">hash</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">tup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hashvalue</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hashvalue</span>

<span class="k">def</span> <span class="nf">_make_key</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="n">typed</span><span class="p">,</span>
             <span class="n">kwd_mark</span> <span class="o">=</span> <span class="p">(</span><span class="nb">object</span><span class="p">(),),</span>
             <span class="n">fasttypes</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">},</span>
             <span class="nb">tuple</span><span class="o">=</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span> <span class="nb">len</span><span class="o">=</span><span class="nb">len</span><span class="p">):</span>
    <span class="sd">"""Make a cache key from optionally typed positional and keyword arguments</span>

<span class="sd">    The key is constructed in a way that is flat as possible rather than</span>
<span class="sd">    as a nested structure that would take more memory.</span>

<span class="sd">    If there is only a single argument and its data type is known to cache</span>
<span class="sd">    its hash value, then that argument is returned without a wrapper.  This</span>
<span class="sd">    saves space and improves lookup speed.</span>

<span class="sd">    """</span>
    <span class="c1"># All of code below relies on kwds preserving the order input by the user.</span>
    <span class="c1"># Formerly, we sorted() the kwds before looping.  The new way is *much*</span>
    <span class="c1"># faster; however, it means that f(x=1, y=2) will now be treated as a</span>
    <span class="c1"># distinct call from f(y=2, x=1) which will be cached separately.</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">args</span>
    <span class="k">if</span> <span class="n">kwds</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">+=</span> <span class="n">kwd_mark</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">kwds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">key</span> <span class="o">+=</span> <span class="n">item</span>
    <span class="k">if</span> <span class="n">typed</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwds</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="n">fasttypes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">_HashedSeq</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">typed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">"""Least-recently-used cache decorator.</span>

<span class="sd">    If *maxsize* is set to None, the LRU features are disabled and the cache</span>
<span class="sd">    can grow without bound.</span>

<span class="sd">    If *typed* is True, arguments of different types will be cached separately.</span>
<span class="sd">    For example, f(3.0) and f(3) will be treated as distinct calls with</span>
<span class="sd">    distinct results.</span>

<span class="sd">    Arguments to the cached function must be hashable.</span>

<span class="sd">    View the cache statistics named tuple (hits, misses, maxsize, currsize)</span>
<span class="sd">    with f.cache_info().  Clear the cache and statistics with f.cache_clear().</span>
<span class="sd">    Access the underlying function with f.__wrapped__.</span>

<span class="sd">    See:  http://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)</span>

<span class="sd">    """</span>

    <span class="c1"># Users should only access the lru_cache through its public API:</span>
    <span class="c1">#       cache_info, cache_clear, and f.__wrapped__</span>
    <span class="c1"># The internals of the lru_cache are encapsulated for thread safety and</span>
    <span class="c1"># to allow the implementation to change (including a possible C version).</span>

    <span class="c1"># Early detection of an erroneous call to @lru_cache without any arguments</span>
    <span class="c1"># resulting in the inner function being passed to maxsize instead of an</span>
    <span class="c1"># integer or None.  Negative maxsize is treated as 0.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maxsize</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">maxsize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">maxsize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'Expected maxsize to be an integer or None'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">decorating_function</span><span class="p">(</span><span class="n">user_function</span><span class="p">):</span>
        <span class="n">wrapper</span> <span class="o">=</span> <span class="n">_lru_cache_wrapper</span><span class="p">(</span><span class="n">user_function</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">,</span> <span class="n">typed</span><span class="p">,</span> <span class="n">_CacheInfo</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">update_wrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">user_function</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">decorating_function</span>

<span class="k">def</span> <span class="nf">_lru_cache_wrapper</span><span class="p">(</span><span class="n">user_function</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">,</span> <span class="n">typed</span><span class="p">,</span> <span class="n">_CacheInfo</span><span class="p">):</span>
    <span class="c1"># Constants shared by all lru cache instances:</span>
    <span class="n">sentinel</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>          <span class="c1"># unique object used to signal cache misses</span>
    <span class="n">make_key</span> <span class="o">=</span> <span class="n">_make_key</span>         <span class="c1"># build a key from the function arguments</span>
    <span class="n">PREV</span><span class="p">,</span> <span class="n">NEXT</span><span class="p">,</span> <span class="n">KEY</span><span class="p">,</span> <span class="n">RESULT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>   <span class="c1"># names for the link fields</span>

    <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">hits</span> <span class="o">=</span> <span class="n">misses</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">full</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">cache_get</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span>    <span class="c1"># bound method to lookup a key or return None</span>
    <span class="n">cache_len</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="fm">__len__</span>  <span class="c1"># get cache size without calling len()</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">RLock</span><span class="p">()</span>           <span class="c1"># because linkedlist updates aren't threadsafe</span>
    <span class="n">root</span> <span class="o">=</span> <span class="p">[]</span>                <span class="c1"># root of the circular doubly linked list</span>
    <span class="n">root</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>     <span class="c1"># initialize by pointing to self</span>

    <span class="k">if</span> <span class="n">maxsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
            <span class="c1"># No caching -- just a statistics update</span>
            <span class="k">nonlocal</span> <span class="n">misses</span>
            <span class="n">misses</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">user_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">elif</span> <span class="n">maxsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
            <span class="c1"># Simple caching without ordering or size limit</span>
            <span class="k">nonlocal</span> <span class="n">hits</span><span class="p">,</span> <span class="n">misses</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">make_key</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="n">typed</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">cache_get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">sentinel</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">sentinel</span><span class="p">:</span>
                <span class="n">hits</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="n">misses</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">user_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
            <span class="c1"># Size limited caching that tracks accesses by recency</span>
            <span class="k">nonlocal</span> <span class="n">root</span><span class="p">,</span> <span class="n">hits</span><span class="p">,</span> <span class="n">misses</span><span class="p">,</span> <span class="n">full</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">make_key</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="n">typed</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
                <span class="n">link</span> <span class="o">=</span> <span class="n">cache_get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">link</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Move the link to the front of the circular queue</span>
                    <span class="n">link_prev</span><span class="p">,</span> <span class="n">link_next</span><span class="p">,</span> <span class="n">_key</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">link</span>
                    <span class="n">link_prev</span><span class="p">[</span><span class="n">NEXT</span><span class="p">]</span> <span class="o">=</span> <span class="n">link_next</span>
                    <span class="n">link_next</span><span class="p">[</span><span class="n">PREV</span><span class="p">]</span> <span class="o">=</span> <span class="n">link_prev</span>
                    <span class="n">last</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="n">PREV</span><span class="p">]</span>
                    <span class="n">last</span><span class="p">[</span><span class="n">NEXT</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="n">PREV</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span>
                    <span class="n">link</span><span class="p">[</span><span class="n">PREV</span><span class="p">]</span> <span class="o">=</span> <span class="n">last</span>
                    <span class="n">link</span><span class="p">[</span><span class="n">NEXT</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span>
                    <span class="n">hits</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">return</span> <span class="n">result</span>
                <span class="n">misses</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">user_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                    <span class="c1"># Getting here means that this same key was added to the</span>
                    <span class="c1"># cache while the lock was released.  Since the link</span>
                    <span class="c1"># update is already done, we need only return the</span>
                    <span class="c1"># computed result and update the count of misses.</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="n">full</span><span class="p">:</span>
                    <span class="c1"># Use the old root to store the new key and result.</span>
                    <span class="n">oldroot</span> <span class="o">=</span> <span class="n">root</span>
                    <span class="n">oldroot</span><span class="p">[</span><span class="n">KEY</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
                    <span class="n">oldroot</span><span class="p">[</span><span class="n">RESULT</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
                    <span class="c1"># Empty the oldest link and make it the new root.</span>
                    <span class="c1"># Keep a reference to the old key and old result to</span>
                    <span class="c1"># prevent their ref counts from going to zero during the</span>
                    <span class="c1"># update. That will prevent potentially arbitrary object</span>
                    <span class="c1"># clean-up code (i.e. __del__) from running while we're</span>
                    <span class="c1"># still adjusting the links.</span>
                    <span class="n">root</span> <span class="o">=</span> <span class="n">oldroot</span><span class="p">[</span><span class="n">NEXT</span><span class="p">]</span>
                    <span class="n">oldkey</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="n">KEY</span><span class="p">]</span>
                    <span class="n">oldresult</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="n">RESULT</span><span class="p">]</span>
                    <span class="n">root</span><span class="p">[</span><span class="n">KEY</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="n">RESULT</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="c1"># Now update the cache dictionary.</span>
                    <span class="k">del</span> <span class="n">cache</span><span class="p">[</span><span class="n">oldkey</span><span class="p">]</span>
                    <span class="c1"># Save the potentially reentrant cache[key] assignment</span>
                    <span class="c1"># for last, after the root and links have been put in</span>
                    <span class="c1"># a consistent state.</span>
                    <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldroot</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Put result in a new link at the front of the queue.</span>
                    <span class="n">last</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="n">PREV</span><span class="p">]</span>
                    <span class="n">link</span> <span class="o">=</span> <span class="p">[</span><span class="n">last</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">result</span><span class="p">]</span>
                    <span class="n">last</span><span class="p">[</span><span class="n">NEXT</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="n">PREV</span><span class="p">]</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span>
                    <span class="c1"># Use the cache_len bound method instead of the len() function</span>
                    <span class="c1"># which could potentially be wrapped in an lru_cache itself.</span>
                    <span class="n">full</span> <span class="o">=</span> <span class="p">(</span><span class="n">cache_len</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">maxsize</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">cache_info</span><span class="p">():</span>
        <span class="sd">"""Report cache statistics"""</span>
        <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_CacheInfo</span><span class="p">(</span><span class="n">hits</span><span class="p">,</span> <span class="n">misses</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">,</span> <span class="n">cache_len</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">cache_clear</span><span class="p">():</span>
        <span class="sd">"""Clear the cache and cache statistics"""</span>
        <span class="k">nonlocal</span> <span class="n">hits</span><span class="p">,</span> <span class="n">misses</span><span class="p">,</span> <span class="n">full</span>
        <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
            <span class="n">cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">root</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">hits</span> <span class="o">=</span> <span class="n">misses</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">full</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">wrapper</span><span class="o">.</span><span class="n">cache_info</span> <span class="o">=</span> <span class="n">cache_info</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="n">cache_clear</span> <span class="o">=</span> <span class="n">cache_clear</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">_functools</span> <span class="kn">import</span> <span class="n">_lru_cache_wrapper</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="c1">################################################################################</span>
<span class="c1">### singledispatch() - single-dispatch generic function decorator</span>
<span class="c1">################################################################################</span>

<span class="k">def</span> <span class="nf">_c3_merge</span><span class="p">(</span><span class="n">sequences</span><span class="p">):</span>
    <span class="sd">"""Merges MROs in *sequences* to a single MRO using the C3 algorithm.</span>

<span class="sd">    Adapted from http://www.python.org/download/releases/2.3/mro/.</span>

<span class="sd">    """</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">sequences</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sequences</span> <span class="k">if</span> <span class="n">s</span><span class="p">]</span>   <span class="c1"># purge empty sequences</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sequences</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">sequences</span><span class="p">:</span>   <span class="c1"># find merge candidates among seq heads</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="n">sequences</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">s2</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">candidate</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">break</span>      <span class="c1"># reject the current head, it appears later</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">candidate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Inconsistent hierarchy"</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
        <span class="c1"># remove the chosen candidate</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">sequences</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">candidate</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_c3_mro</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">abcs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""Computes the method resolution order using extended C3 linearization.</span>

<span class="sd">    If no *abcs* are given, the algorithm works exactly like the built-in C3</span>
<span class="sd">    linearization used for method resolution.</span>

<span class="sd">    If given, *abcs* is a list of abstract base classes that should be inserted</span>
<span class="sd">    into the resulting MRO. Unrelated ABCs are ignored and don't end up in the</span>
<span class="sd">    result. The algorithm inserts ABCs where their functionality is introduced,</span>
<span class="sd">    i.e. issubclass(cls, abc) returns True for the class itself but returns</span>
<span class="sd">    False for all its direct base classes. Implicit ABCs for a given class</span>
<span class="sd">    (either registered or inferred from the presence of a special method like</span>
<span class="sd">    __len__) are inserted directly after the last ABC explicitly listed in the</span>
<span class="sd">    MRO of said class. If two implicit ABCs end up next to each other in the</span>
<span class="sd">    resulting MRO, their ordering depends on the order of types in *abcs*.</span>

<span class="sd">    """</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">'__abstractmethods__'</span><span class="p">):</span>
            <span class="n">boundary</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span>
            <span class="k">break</span>   <span class="c1"># Bases up to the last explicit ABC are considered first.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">boundary</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">abcs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">abcs</span><span class="p">)</span> <span class="k">if</span> <span class="n">abcs</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="n">explicit_bases</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">[:</span><span class="n">boundary</span><span class="p">])</span>
    <span class="n">abstract_bases</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">other_bases</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">[</span><span class="n">boundary</span><span class="p">:])</span>
    <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">abcs</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
                <span class="nb">issubclass</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span>
            <span class="p">):</span>
            <span class="c1"># If *cls* is the class that introduces behaviour described by</span>
            <span class="c1"># an ABC *base*, insert said ABC to its MRO.</span>
            <span class="n">abstract_bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">abstract_bases</span><span class="p">:</span>
        <span class="n">abcs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
    <span class="n">explicit_c3_mros</span> <span class="o">=</span> <span class="p">[</span><span class="n">_c3_mro</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">abcs</span><span class="o">=</span><span class="n">abcs</span><span class="p">)</span> <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">explicit_bases</span><span class="p">]</span>
    <span class="n">abstract_c3_mros</span> <span class="o">=</span> <span class="p">[</span><span class="n">_c3_mro</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">abcs</span><span class="o">=</span><span class="n">abcs</span><span class="p">)</span> <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">abstract_bases</span><span class="p">]</span>
    <span class="n">other_c3_mros</span> <span class="o">=</span> <span class="p">[</span><span class="n">_c3_mro</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">abcs</span><span class="o">=</span><span class="n">abcs</span><span class="p">)</span> <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">other_bases</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">_c3_merge</span><span class="p">(</span>
        <span class="p">[[</span><span class="bp">cls</span><span class="p">]]</span> <span class="o">+</span>
        <span class="n">explicit_c3_mros</span> <span class="o">+</span> <span class="n">abstract_c3_mros</span> <span class="o">+</span> <span class="n">other_c3_mros</span> <span class="o">+</span>
        <span class="p">[</span><span class="n">explicit_bases</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">abstract_bases</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">other_bases</span><span class="p">]</span>
    <span class="p">)</span>

<span class="k">def</span> <span class="nf">_compose_mro</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">types</span><span class="p">):</span>
    <span class="sd">"""Calculates the method resolution order for a given class *cls*.</span>

<span class="sd">    Includes relevant abstract base classes (with their respective bases) from</span>
<span class="sd">    the *types* iterable. Uses a modified C3 linearization algorithm.</span>

<span class="sd">    """</span>
    <span class="n">bases</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">)</span>
    <span class="c1"># Remove entries which are already present in the __mro__ or unrelated.</span>
    <span class="k">def</span> <span class="nf">is_related</span><span class="p">(</span><span class="n">typ</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">typ</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bases</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="s1">'__mro__'</span><span class="p">)</span>
                                 <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">typ</span><span class="p">))</span>
    <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">types</span> <span class="k">if</span> <span class="n">is_related</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="c1"># Remove entries which are strict bases of other entries (they will end up</span>
    <span class="c1"># in the MRO anyway.</span>
    <span class="k">def</span> <span class="nf">is_strict_base</span><span class="p">(</span><span class="n">typ</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">typ</span> <span class="o">!=</span> <span class="n">other</span> <span class="ow">and</span> <span class="n">typ</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">types</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">is_strict_base</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="c1"># Subclasses of the ABCs in *types* which are also implemented by</span>
    <span class="c1"># *cls* can be used to stabilize ABC ordering.</span>
    <span class="n">type_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>
    <span class="n">mro</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">typ</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
        <span class="n">found</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">typ</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sub</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bases</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">sub</span><span class="p">):</span>
                <span class="n">found</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sub</span><span class="o">.</span><span class="vm">__mro__</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">type_set</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
            <span class="n">mro</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="c1"># Favor subclasses with the biggest number of useful bases</span>
        <span class="n">found</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">found</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">subcls</span> <span class="ow">in</span> <span class="n">sub</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">subcls</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mro</span><span class="p">:</span>
                    <span class="n">mro</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subcls</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_c3_mro</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">abcs</span><span class="o">=</span><span class="n">mro</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_find_impl</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">registry</span><span class="p">):</span>
    <span class="sd">"""Returns the best matching implementation from *registry* for type *cls*.</span>

<span class="sd">    Where there is no registered implementation for a specific type, its method</span>
<span class="sd">    resolution order is used to find a more generic implementation.</span>

<span class="sd">    Note: if *registry* does not contain an implementation for the base</span>
<span class="sd">    *object* type, this function may return None.</span>

<span class="sd">    """</span>
    <span class="n">mro</span> <span class="o">=</span> <span class="n">_compose_mro</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">registry</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">match</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">mro</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If *match* is an implicit ABC but there is another unrelated,</span>
            <span class="c1"># equally matching implicit ABC, refuse the temptation to guess.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="ow">in</span> <span class="n">registry</span> <span class="ow">and</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span>
                              <span class="ow">and</span> <span class="n">match</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span>
                              <span class="ow">and</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="n">t</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Ambiguous dispatch: </span><span class="si">{}</span><span class="s2"> or </span><span class="si">{}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">match</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
            <span class="k">break</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">registry</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">t</span>
    <span class="k">return</span> <span class="n">registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">singledispatch</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">"""Single-dispatch generic function decorator.</span>

<span class="sd">    Transforms a function into a generic function, which can have different</span>
<span class="sd">    behaviours depending upon the type of its first argument. The decorated</span>
<span class="sd">    function acts as the default implementation, and additional</span>
<span class="sd">    implementations can be registered using the register() attribute of the</span>
<span class="sd">    generic function.</span>
<span class="sd">    """</span>
    <span class="c1"># There are many programs that use functools without singledispatch, so we</span>
    <span class="c1"># trade-off making singledispatch marginally slower for the benefit of</span>
    <span class="c1"># making start-up of such applications slightly faster.</span>
    <span class="kn">import</span> <span class="nn">types</span><span class="o">,</span> <span class="nn">weakref</span>

    <span class="n">registry</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">dispatch_cache</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">()</span>
    <span class="n">cache_token</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">"""generic_func.dispatch(cls) -&gt; &lt;function implementation&gt;</span>

<span class="sd">        Runs the dispatch algorithm to return the best available implementation</span>
<span class="sd">        for the given *cls* registered on *generic_func*.</span>

<span class="sd">        """</span>
        <span class="k">nonlocal</span> <span class="n">cache_token</span>
        <span class="k">if</span> <span class="n">cache_token</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">current_token</span> <span class="o">=</span> <span class="n">get_cache_token</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cache_token</span> <span class="o">!=</span> <span class="n">current_token</span><span class="p">:</span>
                <span class="n">dispatch_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="n">cache_token</span> <span class="o">=</span> <span class="n">current_token</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">impl</span> <span class="o">=</span> <span class="n">dispatch_cache</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">impl</span> <span class="o">=</span> <span class="n">registry</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">impl</span> <span class="o">=</span> <span class="n">_find_impl</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">registry</span><span class="p">)</span>
            <span class="n">dispatch_cache</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">impl</span>
        <span class="k">return</span> <span class="n">impl</span>

    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""generic_func.register(cls, func) -&gt; func</span>

<span class="sd">        Registers a new implementation for the given *cls* on a *generic_func*.</span>

<span class="sd">        """</span>
        <span class="k">nonlocal</span> <span class="n">cache_token</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                <span class="k">return</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">register</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            <span class="n">ann</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">'__annotations__'</span><span class="p">,</span> <span class="p">{})</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ann</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">"Invalid first argument to `register()`: </span><span class="si">{</span><span class="bp">cls</span><span class="si">!r}</span><span class="s2">. "</span>
                    <span class="sa">f</span><span class="s2">"Use either `@register(some_class)` or plain `@register` "</span>
                    <span class="sa">f</span><span class="s2">"on an annotated function."</span>
                <span class="p">)</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">cls</span>

            <span class="c1"># only import typing if annotation parsing is necessary</span>
            <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">get_type_hints</span>
            <span class="n">argname</span><span class="p">,</span> <span class="bp">cls</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">get_type_hints</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">type</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">"Invalid annotation for </span><span class="si">{</span><span class="n">argname</span><span class="si">!r}</span><span class="s2">. </span><span class="si">{</span><span class="bp">cls</span><span class="si">!r}</span><span class="s2"> is not a class."</span>
            <span class="p">)</span>
        <span class="n">registry</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
        <span class="k">if</span> <span class="n">cache_token</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">'__abstractmethods__'</span><span class="p">):</span>
            <span class="n">cache_token</span> <span class="o">=</span> <span class="n">get_cache_token</span><span class="p">()</span>
        <span class="n">dispatch_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">func</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">funcname</span><span class="si">}</span><span class="s1"> requires at least '</span>
                            <span class="s1">'1 positional argument'</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dispatch</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="n">funcname</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">'__name__'</span><span class="p">,</span> <span class="s1">'singledispatch function'</span><span class="p">)</span>
    <span class="n">registry</span><span class="p">[</span><span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="n">register</span> <span class="o">=</span> <span class="n">register</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="n">dispatch</span> <span class="o">=</span> <span class="n">dispatch</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="n">registry</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">MappingProxyType</span><span class="p">(</span><span class="n">registry</span><span class="p">)</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="n">_clear_cache</span> <span class="o">=</span> <span class="n">dispatch_cache</span><span class="o">.</span><span class="n">clear</span>
    <span class="n">update_wrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.5',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
<script src="../_static/documentation_options.js" type="text/javascript"></script>
<script src="../_static/jquery.js" type="text/javascript"></script>
<script src="../_static/underscore.js" type="text/javascript"></script>
<script src="../_static/doctools.js" type="text/javascript"></script>
<script src="../_static/js/theme.js" type="text/javascript"></script>
<div class="footer" role="contentinfo">
<div class="container">
            © Copyright 2021, Wilfried Mercier.
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.4.0.
        </div>
</div>
</body>
